//#Include <iostream>
//#Include <string>
//#Include <Vector>
//#Include <nordered_map>
//// std :: string getName ()
//// {
//// return "cherno";
////}
// Auto getName () -> Char*
// {{
// Return "Cherno";
//}
// class device {};
// Class DeviceManager
// {{
// Private:
// std :: unianred_map <std :: string, std :: vector <device*>> m_devices;
// public:
// const std :: unordered_map <std :: string, std :: vector <device*>> & getDevices () Const
// {{
// Return m_devices;
//}
//};
// int Main ()
// {{
// Auto C = 5; // Auto a bit turned C ++ into a weak type language
// int a = 5;
// Auto B = A;
// std :: string name = getName ();
// Auto name = getName (); // If the API here is changed to char*, then the next code will report an error, so here is tendency to use the above
///// The code of that line
// int a = name.size ();
// sTD :: COUT << B << STD :: Endl;
// sTD :: vector <std :: String> Strings;
//strings.push_back.com);
//strings.push_back.com ");
// /*for (std :: vector <std :: string> :: Iterator it = strings.begin (); it! = strings.end (); it ++)
// std :: COUT << *it << STD :: Endl; */
// for (auto it = strings.begin (); it! = strings.end (); it ++)
// // std :: count << *it << STD :: Endl; // This situation can be used in auto
// using deviceMap = STD :: Unordered_map <std :: String, std :: vector <device*>>; // New features
// // TypeDef STD :: Unordered_map <sTD :: String, STD :: Vector <device*>> DeviceMap; // Old features
// DeviceManager DM;
// const std :: unianRed_map <std :: String, STD :: Vector <device*>> & Deural
// const deviceMap & Devices1 = dm.getDevices ();
// const auto & devices2 = dm.getDevices ();
// Auto Devices3 = dm.getDevices (); // Auto does not handle any const and & &
// std :: cin.get ();
//}